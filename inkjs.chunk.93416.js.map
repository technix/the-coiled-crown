{"version":3,"sources":["webpack:///../node_modules/inkjs/src/engine/TypeAssertion.ts","webpack:///../node_modules/inkjs/src/engine/NullException.ts","webpack:///../node_modules/inkjs/src/engine/TryGetResult.ts","webpack:///../node_modules/inkjs/src/engine/Debug.ts","webpack:///../node_modules/inkjs/src/engine/Value.ts","webpack:///../node_modules/inkjs/src/engine/PushPop.ts","webpack:///../node_modules/inkjs/src/engine/Error.ts","webpack:///../node_modules/inkjs/src/engine/Path.ts","webpack:///../node_modules/inkjs/src/engine/Object.ts","webpack:///../node_modules/inkjs/src/engine/StringBuilder.ts","webpack:///../node_modules/inkjs/src/engine/InkList.ts","webpack:///../node_modules/inkjs/src/engine/StoryException.ts","webpack:///../node_modules/inkjs/src/engine/SearchResult.ts","webpack:///../node_modules/inkjs/src/engine/Container.ts","webpack:///../node_modules/inkjs/src/engine/Glue.ts","webpack:///../node_modules/inkjs/src/engine/ControlCommand.ts","webpack:///../node_modules/inkjs/src/engine/Pointer.ts","webpack:///../node_modules/inkjs/src/engine/Divert.ts","webpack:///../node_modules/inkjs/src/engine/ChoicePoint.ts","webpack:///../node_modules/inkjs/src/engine/VariableReference.ts","webpack:///../node_modules/inkjs/src/engine/VariableAssignment.ts","webpack:///../node_modules/inkjs/src/engine/Void.ts","webpack:///../node_modules/inkjs/src/engine/NativeFunctionCall.ts","webpack:///../node_modules/inkjs/src/engine/Tag.ts","webpack:///../node_modules/inkjs/src/engine/Choice.ts","webpack:///../node_modules/inkjs/src/engine/ListDefinition.ts","webpack:///../node_modules/inkjs/src/engine/ListDefinitionsOrigin.ts","webpack:///../node_modules/inkjs/src/engine/JsonSerialisation.ts","webpack:///../node_modules/inkjs/src/engine/CallStack.ts","webpack:///../node_modules/inkjs/src/engine/VariablesState.ts","webpack:///../node_modules/inkjs/src/engine/PRNG.ts","webpack:///../node_modules/inkjs/src/engine/StatePatch.ts","webpack:///../node_modules/inkjs/src/engine/SimpleJson.ts","webpack:///../node_modules/inkjs/src/engine/Flow.ts","webpack:///../node_modules/inkjs/src/engine/StoryState.ts","webpack:///../node_modules/inkjs/src/engine/StopWatch.ts","webpack:///../node_modules/inkjs/src/engine/Story.ts"],"names":["s","t","e","l","Error","concat","o","hasValidName","name","u","h","_typeof","Equals","p","d","C","n","result","exists","i","get","r","a","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","push","Array","_createClass","key","length","slice","self","isIndex","value","isParent","join","isRelative","set","substring","_step","_iterator","_createForOfIteratorHelper","split","done","test","parseInt","err","f","_n$_components","apply","_toConsumableArray","parentId","index","toString","console","warn","trace","AssertType","Assert","_Error","_super","_inherits","_createSuper","_wrapNativeSuper","m","parent","_debugMetadata","_path","debugMetadata","rootContentContainer","ContentAtPath","obj","startLineNumber","x","unshift","content","indexOf","GetComponent","tail","path","Math","min","componentCount","ToParent","PathByAppendingPath","ConvertPathToRelative","string","Append","_len","_key","replace","g","originName","itemName","fullName","JSON","stringify","parse","isLikeInkListItem","Null","hasOwnProperty","S","_Map","_this","_super2","call","origins","_originNames","originNames","SetInitialOriginName","listDefinitions","_possibleConstructorReturn","TryListGetDefinition","Add","Key","Value","AddItem","_step2","_iterator2","TryGetValueForItem","_step3","_iterator3","ContainsItemWithName","ValueForItem","_step4","_iterator4","_step4$value","_slicedToArray","fromSerializedKey","has","serialized","delete","size","maxItem","every","Count","_step5","_iterator5","_step5$value","_step6","_iterator6","_step6$value","isNull","_step7","_iterator7","_step7$value","_step8","_iterator8","_step9","_iterator9","items","_step9$value","ContainsKey","_step10","_iterator10","_step11","_iterator11","_step11$value","_step12","_iterator12","_step12$value","_step13","_iterator13","_step13$value","_step14","_iterator14","_step14$value","_step15","_iterator15","_step15$value","ContainsItemNamed","_step16","_iterator16","_step16$value","minItem","orderedItems","Number","MAX_SAFE_INTEGER","isInteger","SetInitialOriginNames","_step17","_iterator17","_step18","_iterator18","_step18$value","_step19","_iterator19","_step19$value","sort","localeCompare","NaN","FindSingleItemListWithName","Map","y","_Error2","_this2","_super3","useEndLineNumber","message","v","_m","_super4","Create","valueObject","valueType","Int","w","Float","isNaN","T","_","Boolean","E","String","P","O","b","_v","_this3","_super5","_b","_super6","Bool","BadCastException","_b2","_super7","_b3","_super8","_b4","_this4","_super9","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","undefined","parseFloat","_b5","_super10","DivertTarget","targetPath","N","_b6","_this5","_super11","_contextIndex","VariablePointer","variableName","contextIndex","_b7","_this6","_super12","List","A","approximate","_m2","_this7","_super13","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","AddContent","_step20","_iterator20","_step20$value","_step21","_iterator21","namedOnlyContent","_step22","_iterator22","_step22$value","_step23","_iterator23","AddToNamedContentOnly","CountFlags","Visits","Turns","CountStartOnly","internalPathToFirstLeafContent","_step24","_iterator24","TryAddNamedContent","ContentWithPathComponent","splice","_this$content","_step25","_iterator25","BuildStringOfHierarchy","AppendFormat","AppendLine","_step26","_iterator26","_step26$value","_step27","_iterator27","I","_m3","_super14","k","_m4","_this8","CommandType","NotSet","_super15","_commandType","commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","TOTAL_VALUES","Tunnel","Function","FunctionEvaluationFromGame","F","container","PathByAppendingComponent","W","_m5","_this9","_super16","_targetPath","_targetPointer","variableDivertName","pushesToStack","stackPushType","isExternal","externalArgs","isConditional","targetPointer","Resolve","ResolvePath","lastComponent","StartOf","copy","CompactPathString","hasVariableTarget","targetPathString","V","_m6","_this10","_super17","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","onceOnly","choiceTarget","pathOnChoice","L","_m7","_this11","_super18","pathForCount","pathStringForCount","R","_m8","_this12","_super19","isNewDeclaration","isGlobal","D","_m9","_super20","j","_m10","_this13","_super21","_name","_numberOfParameters","_prototype","_isPrototype","_operationFuncs","GenerateNativeFunctionsIfNecessary","numberOfParameters","_nativeFunctions","Call","_step28","_iterator28","CallBinaryListOperation","CoerceValuesToSingleType","CallType","CallListIncrementOperation","isTruthy","_step29","_iterator29","_step29$value","_step30","_iterator30","TryGetItemWithValue","_step31","_iterator31","_step32","_iterator32","originOfMaxItem","_step33","_iterator33","Cast","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","AddOpFuncForType","B","_m11","_this14","_super22","text","G","_m12","_this15","_super23","threadAtGeneration","sourcePath","tags","originalThreadIndex","M","_items","_itemNameToValues","_step34","_iterator34","_step34$value","_step35","_iterator35","_step35$value","J","_lists","_allUnambiguousListValueCache","_step36","_iterator36","_step37","_iterator37","_step37$value","_step38","_iterator38","_step38$value","q","JTokenToRuntimeObject","WriteObjectStart","_step39","_iterator39","_step39$value","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","_step40","_iterator40","WriteArrayEnd","_step41","_iterator41","_step41$value","WriteIntProperty","WriteRuntimeContainer","WriteProperty","pathStringOnChoice","flags","WriteBool","WriteInt","WriteFloat","Write","WriteStringStart","WriteStringInner","WriteStringEnd","c","WriteInkList","_controlCommandNames","WriteChoice","CallExistsWithName","CallWithName","isArray","ci","var","exArgs","flg","re","list","originalChoicePath","JObjectToChoice","JArrayToContainer","toJson","some","_step42","_iterator42","countFlags","_step43","_iterator43","_step43$value","WriteNull","JArrayToRuntimeObjList","_step44","_iterator44","_step45","_iterator45","_step45$value","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","_step46","_iterator46","_step47","_iterator47","lists","_step48","_iterator48","_step48$value","U","_threadCounter","_startOfRoot","Z","Reset","_threads","_step49","_iterator49","Copy","callStack","elements","callstack","Thread","Element","_step50","_iterator50","threads","threadCounter","_this16","WriteObject","_step51","_iterator51","WriteJson","currentThread","threadIndex","canPopThread","elementIsEvaluateFromGame","currentElement","type","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","canPop","CanPop","pop","currentElementIndex","temporaryVariables","RetainListOriginsForAssignment","filter","inExpressionEvaluation","previousPointer","_step52","_iterator52","cPath","idx","Warning","exp","temp","JObjectToDictionaryRuntimeObjs","clear","previousContentObject","PointerAtPath","_step53","_iterator53","_step54","_iterator54","WriteDictionaryRuntimeObjs","K","_ref","_this17","_super24","variableChangedEventCallbacks","patch","_batchObservingVariableChanges","_defaultGlobalVariables","_changedVariablesForBatchObs","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","_assertThisInitialized","$","_step55","_iterator55","_step56","_iterator56","variableChangedEvent","TryGetGlobal","SetGlobal","_step57","_iterator57","globals","_step57$value","_step58","_iterator58","changedVariables","add","_step59","_iterator59","_step59$value","_step60","_iterator60","_step60$value","dontSaveDefaultValues","RuntimeObjectsEqual","constructor","GetRawVariableWithName","ValueAtVariablePointer","GetTemporaryVariableWithName","GetVariableWithName","GlobalVariableExistsWithName","ResolveVariablePointer","SetTemporaryVariable","batchObservingVariableChanges","AddChangedVariable","GetContextIndexOfVariableNamed","z","seed","next","H","_changedVariables","_visitCounts","_turnIndices","_globals","Reader","ToDictionary","ToArray","_class2","_rootObject","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","StartNewObject","state","Writer","State","Property","currentCollection","currentPropertyName","None","StateElement","Object","IncrementChildCount","childCount","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","X","SetJsonToken","outputStream","currentChoices","choiceThreads","LoadFlowChoiceThreads","_this18","WriteListRuntimeObjs","_step61","_iterator61","ThreadWithIndex","_step62","_iterator62","_step63","_iterator63","Y","kInkSaveStateVersion","kMinCompatibleLoadVersion","onDidLoadState","_currentErrors","_currentWarnings","divertedPointer","_currentTurnIndex","storySeed","previousRandom","didSafeExit","_currentText","_currentTags","_outputStreamTextDirty","_outputStreamTagsDirty","_patch","_aliveFlowNames","_namedFlows","kDefaultFlowName","_aliveFlowNamesDirty","story","_currentFlow","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","Date","getTime","GoToStart","ToJson","TextToDictionary","LoadJsonObj","TryGetVisitCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","depth","canContinue","hasError","currentErrors","currentWarnings","_step64","_iterator64","CleanOutputWhitespace","charAt","_step65","_iterator65","Length","Clear","_step66","_iterator66","keys","mainContentContainer","variablesState","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","_t$_currentFlow$curre","_t$_currentFlow$outpu","_t$_currentErrors","_t$_currentWarnings","_t$evaluationStack","_step67","_iterator67","_step67$value","hasWarning","evaluationStack","ApplyPatch","_step68","_iterator68","visitCounts","_step68$value","ApplyCountChanges","_step69","_iterator69","turnIndices","_step69$value","_this19","_step70","_iterator70","_loop","_step70$value","WriteIntDictionary","inkVersionCurrent","inkSaveVersion","flows","_i37","_e104","entries","_e104$_i","currentFlowName","callstackThreads","evalStack","currentDivertTarget","JObjectToIntDictionary","turnIdx","_this$outputStream","TrySplittingHeadTailWhitespace","_step71","_iterator71","PushToOutputStreamIndividual","TrimNewlinesFromOutputStream","isNonWhitespace","RemoveExistingGlue","outputStreamEndsInNewline","outputStreamContainsContent","_step72","_iterator72","_step73","_iterator73","TrimWhitespaceFromFunctionEnd","Pop","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","PopEvaluationStack","PopCallStack","Q","startTime","Author","isFinite","_m13","_this20","_super25","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_listDefinitions","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","_externals","inkVersion","root","listDefs","JTokenToListDefinitions","ResetState","_state","_step74","_iterator74","IfAsyncWeCant","currentText","currentTags","currentFlowIsDefaultFlow","aliveFlowNames","_this21","_step75","_iterator75","_step76","_iterator76","_step76$value","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","RemoveFlow_Internal","ContinueAsync","ValidateExternalBindings","PreContinue","ResetOutput","Start","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","RestoreStateSnapshot","generatedChoices","PostContinue","_step77","_iterator77","_step78","_iterator78","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","NoChange","Continue","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","VisitContainer","PerformLogicAndFlowControl","ProcessChoice","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","PeekEvaluationStack","IsTruthy","PopChoiceStringAndTags","ForkThread","reverse","CallExternalFunction","sourceName","TryExitFunctionEvaluationFromGame","PopFromOutputStream","_i48","_t127","_i51","_e133","_step79","_iterator79","correctObj","TurnsSinceForContainer","NextSequenceShuffleIndex","PopThread","ListWithSubRange","Assign","containerForCount","ResetCallstack","SetChosenPath","VisitChangedContainersDueToDivert","KnotContainerWithName","trim","StartFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","returned","output","lookAheadSafe","function","_this22","BindExternalFunctionGeneral","TryCoerce","from","_step80","_iterator80","_step81","_iterator81","_step81$value","ObserveVariable","_step82","_iterator82","_step83","_iterator83","TagsAtStartOfFlowContainerWithPathString","_step84","_iterator84","IncrementContentPointer","charCodeAt","currentDebugMetadata","fileName","endLineNumber","InkList","Story","defineProperty"],"mappings":"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","file":"inkjs.chunk.93416.js","sourcesContent":["import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    if (jObj[\"tags\"]) {\n      choice.tags = jObj[\"tags\"];\n    }\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    if (choice.tags) {\n      writer.WriteProperty(\"tags\", (w) => {\n        w.WriteArrayStart();\n        for (const tag of choice.tags!) {\n          w.WriteStringStart();\n          w.WriteStringInner(tag);\n          w.WriteStringEnd();\n        }\n        w.WriteArrayEnd();\n      });\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string, bool or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"sourceRoot":""}